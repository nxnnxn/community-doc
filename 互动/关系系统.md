| 版本 | 时间      | 修改人 | 备注 |
| ---- | --------- | ------ | ---- |
| V1.0 | 2022.9.22 |        |      |

## 1.需求背景

### 1.1.需求概述



### 1.2.需求干系人

> 单独拆分需求相关人员，用于冲突(WHO)

| 人员   | 项目角色 |
| ------ | -------- |
| 聂向南 | 研发     |

### 1.3.约束和限制

> 8C 指的是 8 个约束和限制,即 Constraints，包括性能 Performance、成本 Cost、时间 Time、可靠性 Reliability、安全性Security、合规性 Compliance、技术性 Technology、兼容性 Compatibility,前面定义目标的时候技术必须定义性能和可靠性因此在这里可以不定义<br>需求中涉及的成本,时间等仅仅是利益关联方提出的诉求，不一定准确；如果经过分析有的约束没有必要，或成本太高、难度太大，这些约束是可以调整的
>
> | 约束和限制 |                           条件                           |
> | :--------: | :------------------------------------------------------: |
> |    时间    |                   产运期望一个月内上线                   |
> |    成本    | 硬件成本:预算大概有年100W左右,人力成本:全力投入大概7个人 |
> |    安全    |                    需要注意防资产损失                    |
> |    合规    |              敏感数据和隐私数据如何保证合规              |
> |    技术    |     目前团队主要研发人员是 Java，最好用 Java 开发。      |
> |    兼容    |              业务上需要历史老接口,需要兼容               |

### 1.4.技术目标

> 任何架构总得有个技术目标,至少在稳定性和性能上要有最基本的,其他的指标项可以探索,也可以和业务目标绑定,一般不超过5个(WHAT)

| 场景 | 目标 | 备注 |
| ---- | ---- | ---- |
|      |      |      |

### 1.5.术语

> 领域模型

| 术语 | 定义 | 备注 |
| ---- | ---- | ---- |
|      |      |      |

## 2.需求分析

### 2.1.功能分析

#### 2.1.1.用例分析

> BDD模式,用于场景故事,核心是满足用户需求,用例分析需要include相关文档(HOW)



#### 2.1.2.领域模型分析

> 可参考[C4_Model](https://c4model.com/)  使用C4-plantuml绘画,领域模型是系统的上下文,有助于系统边界设计，一般情况领域模型不变的情况下属于L1

![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/system.puml&fmt=svg&cache=no)

1. 整套系统分为关系系统,关系任务系统,关注系统,关系facade系统和关系插件
2. 关系facade是业务的门面,用于对接统一网关,对客户端提供服务。
3. 关系系统是在领域上是业务的底层,所有操作都在这里执行,包含关系写入读取等
4. 关注系统单独抽离出来,存储共用关系系统的底层能力,同时有能力单独读取数据库来做一些自身的业务。
5. 关系插件是一个二方包,用于降低feed系统对系统本身的冲击,直接链接redis,在查询不到的情况通过RPC回流到业务系统是上

### 2.2.技术分析

> 非功能需求分析,核心是分析,通过业务给出的数据,来做预估和分析非功能需求复杂度,是提出问题的过程,而不是给出解决方案.

#### 2.2.1.可用性分析

> 可用性分析一般是复杂的,总体还是先谈指标,再谈设计,核心理念是失败的正常的,如何通过设计来保证高可用.
>
> | 可用性级别 | 系统可用性% | 宕机时间/年 | 宕机时间/月 | 宕机时间/周 | 宕机时间/天 |
> | :--------: | :---------: | :---------: | :---------: | :---------: | :---------: |
> |   不可用   |     90%     |   36.5 天   |   73 小时   |  16.8 小时  |  144 分钟   |
> |  基本可用  |     99%     |  87.6 小时  |  7.3 小时   |  1.68 小时  |  14.4 分钟  |
> |  较高可用  |    99.9%    |  8.76 小时  |  43.8 分钟  |  10.1 分钟  |  1.44 分钟  |
> |   高可用   |   99.99%    | 52.56 分钟  |  4.38 分钟  |   1.01 秒   |   8.64 秒   |
> |  极高可用  |   99.999%   |  5.26 分钟  |  26.28 秒   |   6.06 秒   |   0.86 秒   |
>
> 面向失败的架构设计原则:<br>容灾(主备切换,同城多活,异地多活)----系统统或项目的位置和部署环境。这包括了地理位置、硬件和软件组件的位置,以及数据的存储和处理地点(Where)<br>
> 容错(强弱依赖,降级熔断,资源隔离)----接口强弱依赖评估,外部接口降级熔断<br>
> 容量(稳态容量,尖刺容量,防护流控)----有多少用户？日活/月活有多少,容量需要预估多少
>
> 面向精细化运维管控原则:<br>可灰度(环境管理,版本控制,灰度策略)<br>
> 可观测(监控告警,日志事件,链路追踪)<br>
> 可回滚(配置开关,回滚策略,优雅上下线)
>
> 面向风险的应急快恢原则:<br>故障发现(统一告警,监控大屏,风险预测)<br>
> 故障响应(组织协调,告警关联分析,知识图谱)<br>
> 故障恢复(预案执行,故障自愈,故障复盘)<br>

1. 容量预估
   1. 现有10亿注册用户,平均点赞数500,无上限,平均收藏数100,平均关注数100,未来可能会支持其他类型，所以总数据位900*
      10亿=9000亿,假设向上取10000亿,假设现状我们有800亿条记录.
   2. 未来增量数据预估:日活2亿,点赞率按照8%,每人关注2来计算,一天2亿*0.08(点赞率)*2大概3200万条记录,收藏我们大概2亿*0.03*
      1.5(收藏率)=900W,向上整体估算5000W/天，我们预估5年,365 * 2*5000W=360亿,现状我们有800亿条记录，所以总体按照1160亿估算
2. 业务高可用
   1. 
3. 技术高可用
   1. 
4. 对于系统来说,关注的业务价值最高,其他的其次,因此针对这些数据来讲，要保证写入,存储和读取的高可用性,针对于除了关注的系统,
   在读取阶段可以适当的降级，关注系统读取阶段要做到高可用。
5. 需要支持异地多机房,未来可支持单元化。

#### 2.2.2.性能分析

1. 写入QPS预估:平均QPS=5000W/3600/24=578,峰值计算逻辑是在20%的时间之内有了80%的流量，5000W*0.8/3600/24/0.2=2314,
   写入流量一般比较小,我们预留一定的系统容量应对后续业务的发展和突然来的峰值,我们将设计目标设定为峰值的5倍,2314*
   5=11574QPS
2. 系统读取流量预估,峰值QPS整体按照10倍预估
   1. 帖子FEED流上获取用户是否被点赞/关注/收藏+各种统计数据,2亿*6(
      一天打开6次)*3(平均下查3个请求)/3600/24=41666，峰值=平均*10=41W
   2. 获取用户粉丝数/接口, 整体流量一般个人主页,平均 QPS2亿*6*0.3(转化)*2(用户重复看)/3600/24=8333,峰值QPS=平均*
      10=4.1W.
   3. 获取用户关注用户列表，获取粉丝列表，这些基本都是点击数字后所展现内容，12.5W*10%=12500QPS
   4. 所以系统需要需要41W+12.5W+1.25W=55W,需要对内扩展支撑25W,因此需要80WQPS

#### 2.2.3.扩展性分析

>可扩展性是指,系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。设计具备良好可扩展性的系统，有两个基本条件：正确预测变化(2年的需求原则),完美应对变化(提炼出“变化层”和“稳定层”,提炼出“抽象层”和“实现层”)

1. 系统要支持未来业务对用户关系的增加,有其通用性,但整体还是一个面对用户的,一个是面对内容的,其他场景需要讨论.
2. 可支持与其他系统做集成,可拆分能力单独服务,如共享系统只需要按照PV在+-;帖子播放次数也是,评论系统可以将数据给到做集成.
   有一些哪怕需要存储detail，但不需要存在性判断,等等设计，因此要类型接入的时候,可以支持自定义.

#### 2.2.4.成本分析

>主要包含使用哪些云服务,通过业务数据预估使用量,从而获得相关费用

1. 技术成本
2. 运营成本

#### 2.2.5.安全分析

>在架构安全上一般依靠运营商或者云服务商强大的带宽和流量清洗的能力,在功能安全XSS 攻击、CSRF 攻击、SQL 注入一般依赖安全团队提供的二放功能包，现阶段我们主要考虑业务架构上如恶意刷单,刷接口等,防止资产损失

#### 2.2.6.其他

>其他分析

## 3.技术选型

> 在这里我要给出解决方案,3-5个备选方案供大家参考,备选方案的差异要比较明显,但不能太细,备选方案的技术不要只局限于已经熟悉的技术

### 3.1. 业务选型

#### 3.1.2.关注是否独立

1. 每块业务都有其独立的特性,都有其迭代的要求,但整个社区系统而言,用户,关注,内容是最重要的,同时在上面可以延展出更多的信息，包含互相关注等等，
   业务上也会和这些关系系统复杂一点。因此建议单独系统,但同时一些能力可以共同使用.

#### 3.1.2. 对外系统接入选择

1. 我们的主查询场景是feed流各种调用我们的数据,因此整体流量比较大。大概有41W QPS都来自这里，如果我们4C8G单台支撑1000QPS的话需要400台机器才可以。
2. 面对这么大量且业务稳定的数据，建议使用SDK封装访问缓存和缓存后RPC能力,从而让整个集群降低负载,但复杂度是需要产品化SDK,不能将SDK随意给出,不然容易将缓存系统暴露出去.

### 3.2. 数据库选型

#### 3.2.1.主数据库选型

1. 业务分析:数据库存储了大量的数据,估算1160亿 * 42/1024/1024/1024=4537G,索引要建立用户到时间,对象到时间,大体基本按照1160* 30/1024/1024/1024*2=6482G,需要11T数据
2. Mysql:如果在mysql上分库分表的需要建立两张表，一张是用户分库分表，一张根据对象分库分表，同时存储一些额外字段的外,需要新增新的字段,如果要查询，需要同时建立新的索引，不利于架构的可扩展性
3. 表格存储:整体建立主表以用户ID作为分区键，同时建立不同的索引,整体表结构式宽表模型,可随意添加,建议使用
4. 成本评估：
   1. 存储成本11T每G大该1.08若打5折,一般价格在11900CNY/月，若买容量包，基本在8000左右，
   2. 计算资源按照2WQPS预估,计算可弹性基本价格在3000左右因此单个成本大概在11000左右,
   3. 总体成本11000*3=33000CNY/月

#### 3.2.2.统计数据库选型

1. 统计维度跟随detail数据一起来完成计算,如用户关注统计,用户粉丝统计等,,在业务上每次计算需要对唯一健后进行+-,空间计算大概200亿*42/1024/1024/1024=558G
2. MYSQL:因为整张表需要固定唯一健,若要下层级看个数,需要重新申请新表来重新计算数据.
3. 表格存储:唯一健后,统计维度数据列可任意,若有新,可拓展rowkey来新增,不用新增表结构.
4. 成本评估
   1. 每G大该1.08若打5折,558*1.08*0.5=300,若容量包,基本200块钱
   2. FEED流基本6条,缓存命中率基本在9成左右,41W*0.1=4.1WQPS,因此向上预估5WQPS,5W=7500,正常流量可弹性*
   3. 总成本=8000*3=24000CNY/月 

  ![](http://fastly.jsdelivr.net/gh/nxnnxn/pic@main/img/202402232126142.png)

数据库总成本=33000+24000=57000CNY/月 一年68.4W

### 3.3 缓存选型

#### 3.3.1.存在型判断

##### 3.3.1.1.技术分析

我们查询场景第一为存在型判断,判断A和B的用户关系是否在,redis中string,set,bitmap,布隆过滤器,布谷鸟过滤器等

   1. string类型很简单，但我们大体只会存储两个long型，共16字节，但redis object,SDS等数据会占用大量的数据因此不适合

   2. set类型,由于用户点赞&收藏无上限,整体会导致会让一些用户成为bigkey.

   3. bitmap由于支持数字型，但我们的帖子ID，用户ID数字过于庞大，超过了2的32次方，哪怕我们只有10亿用户，但用户ID基本是不连续,但唯一，因此不适合。

   4. 布隆过滤器可以告诉我们 “某样东西一定不存在或者可能存在”，也就是说布隆过滤器说这个数不存在则一定不存，布隆过滤器说这个数存在可能不存在,
      前面场景告诉我们大部分推荐出来的数据是我们没有点赞,没有收藏等的.缺点是布隆过滤器不支持删除，假如我们点赞了，将数据添加到过滤器中,后续我们又取消点赞了，
      我们查的时候他有可能告诉我们去他点赞了，这个时候我们再到库里查一下也是可以的.

   5. 布谷鸟过滤器(https://redis.io/docs/data-types/probabilistic/cuckoo-filter/)
      他改进了布隆过滤器不能删除的特性，同时拥有布隆过滤器的能力，但缺点是删除需要替换元素。整体还好，属于redis stack中的能力

   6. 整体看下来用布隆过滤器比较靠谱，实际请求中99%的没有动作的,因此41WQPS其实到达数据库大体有4000差不多.

      ![](http://fastly.jsdelivr.net/gh/nxnnxn/pic@main/img/202402231733687.png)

##### 3.2.1.2.存储选型

1. 存储介质:业务上我们需要对内容数据进行缓存,因此选择内存型.
2. 部署架构:我们需要支撑百万QPS峰值的和较大的存储压力，因此选择使用集群架构.
3. 容灾方案:我们的应用部署模型是同城异地且跨地域多region部署,
4. 容量评估:我们选择100W,0.01区分度,大体2M左右,现状800亿/100W*2M=156.25G,未来1160亿/100W=116000个,共226G左右,一般水位在70%到80%是个比较均很水位,Feed流每次拉取6条数据,每个用户基本落在一个KEY上,整体大概在60W QPS，同时为未来的布隆过滤器重建有一定的余量,因此整体选择256G
5. 成本分析：需要支持异地部署3地,256*3=768G，若打5则，18000 * 3=54000CNY/月

#### 3.3.2.统计数据

##### 3.3.2.1.技术分析

1. 统计数据需要承担所有统计的流量,有几种数据结构string,第二hash
   1. String类型有两种模式，一种是key区分点赞还是关注,value为long型，我们取数据由于集群版本redis支持mget,因此获取多条数据时候多个如点赞数,评论数需要多次MGET。
   2. String的另一种模式是和数据库一样,key就是内容ID或用户ID,value是一个String,若有变化,异步通过消息方式来将数据同步过去
   3. HASH模式,类似于上面,只不过数据已经基本维持在一个HASH表里
   4. 整体检验缓存结构为String,里边是复合数据类型.
2. 统计数据上有很多内容为0的数据,导致缓存穿透,缓存穿透一般用布隆过滤器
   1. 在我们上面设计场景里,只要一条数据不都是0,那么数据库里就存在这个字段,而以推荐模式下大部数据是热数据,基本都有一些互动数
   2. 所有先MGET内容,在挑选缓存不存在的数据,有两种可能一种是缓存过期了,一种是数据库里没有,然后到布隆过滤中查看,若有就查库,若无就直接返回.

##### 3.3.2.1.存储选型

1. 存储介质:业务上我们需要对内容数据进行缓存,因此选择内存型.
2. 部署架构:我们需要支撑百万QPS峰值的和较大的存储压力，因此选择使用集群架构.
3. 容灾方案:我们的应用部署模型是同城异地且跨地域多region部署,
4. 容量评估
   1. 内容有40字节,一个String按照100字节来算，18亿*100/1024/1024/1024=167G
   2. 一个10亿的布隆过滤器2G,用户10亿注册用户基本够了,内容假设库里有100亿数据,未来要支撑200亿计算，大体40G数据,
   3. FEED流每次6条,虽然使用MGET,但到proxy上是会sharding到各个DATA节点去查询的，因此最大整个QPS是41W*6=240W,最差布隆过滤器也查询6次,基本也是480WQPS左右,看性能报告,单分片性能基本在30W左右，假设我们有32分片,基本也在960W左右.整体有余量
   4. 总体来看167+40=207G,由于是缓存,容量会时刻变化,因此也选择256GTAIR缓存集群版本。
5. 成本分析：支持异地部署3地,256*3=768G，若打5则，18000*3=54000CNY/月

### 3.4.技术决策

> 列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。常见的方案质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性等。在评估这些质量属性时，需要遵循架构设计原则
> 1“合适原则”和原则 2“简单原则”，避免贪大求全，基本上某个质量属性能够满足一定时期内业务发展就可以了。

1. 212
2. 212
3. 212

## 4.详细设计

> 可参考[C4_Model](https://c4model.com/)  使用C4-plantuml绘画

### 4.1.应用架构

> 以实际创建的应用为主的架构,重点是可单独运行的进程主要展示哪些逻辑放在哪个应用里,包含了服务端应用,客户端应用,数据库,文件系统,各种中间件等,如果没有新建应用,一般不会做大的改动,属于L2

![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/container.puml&fmt=svg&cache=no)

1. 整套系统分为关系系统,关系任务系统,关注系统,关系facade系统和关系插件
2. 关系facade是业务的门面,用于对接统一网关,对客户端提供服务。
3. 关系系统是在领域上是业务的底层,所有操作都在这里执行,包含关系写入读取等
4. 关注系统单独抽离出来,但写,存储共用关系系统的底层能力,同时有能力单独读取数据库来做一些自身的业务。
5. 关系插件是一个二方包,用于降低feed系统对系统本身的冲击,直接链接redis,在查询不到的情况通过RPC回流到业务系统是上

### 4.2.核心流程

> 以组件为依托,通过组件图和组件时序图来描述核心流程,其中组件为和外部系统做核心交互的业务功能,时序描述这些组件在不同的用户流程下如何运
>
> 组件图属于L3级别

#### 4.2.1.新增&删除流程

> 通过组件图描述基本流程之后,重点要通过文字说明哪些非功能需求在是如何解决的

![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/add/component.puml&fmt=svg&cache=no)

1. 

2. 

3. 安全


##### 4.2.1.1 新增&删除

> 组件下的主要时序图,有可能不只一个,细节描述组件是如何运作的

![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/add/addrelationseq.puml&fmt=svg&cache=no)



#### 4.2.2.查询

> 通过组件图描述基本流程之后,重点要通过文字说明哪些非功能需求在是如何解决的

![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/get/component.puml&fmt=svg)

1. 高可用

2. 高性能

3. 可扩展

4. 安全


##### 4.2.2.1 查询时序

![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/get/getrelationseq.puml&fmt=svg&cache=no)

#### 4.2.3.关注设计

![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/get/component.puml&fmt=svg)

1. 
2. 3
3. 3
4. 

##### 4.2.2.1. 时序

![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/get/getrelationseq.puml&fmt=svg&cache=no)

### 4.3.存储设计

> 系统中数据库表如何设计,缓存如何设计,有哪些消息结构

#### 4.3.1.数据库设计

1. 主表

   ![img](http://fastly.jsdelivr.net/gh/nxnnxn/pic@main/img/202402261652254.png)

2. 索引表

   本地二级索引

   ![](http://fastly.jsdelivr.net/gh/nxnnxn/pic@main/img/202402231647042.png)

   全局索引

   ![](http://fastly.jsdelivr.net/gh/nxnnxn/pic@main/img/202402231647655.png)

3. 统计表

   ![](http://fastly.jsdelivr.net/gh/nxnnxn/pic@main/img/202402231647718.png)

   1. 其中objectId是user_id和主表的object_id
   2. type基于二进制自定义,

| 3个字节             | 2个字节 | 2个字节 |
| ------------------- | ------- | ------- |
| objectId类型(65536) | 预留    | 如闻    |

#### 4.3.2.缓存设计

1. 存在性缓存 //要结构化
   1. 选择100W,0.01区分度,大体2M左右,按照key=user_id%100000来做sharding做布隆过滤器,item=userId:objectId:
      objectType+actionType.
   2. 查询带宽统计每次查询8+8+2=18字节,关注/点赞/收藏需要查3个actionType,每次有6条数据,因此, 18*6*
      3=324字节,QPS在41W左右，21W*324/1024=126M带宽,整体还好
   3. 在每隔一年需要开启布隆过滤器重建,重建过程需要扫描数据库按照每个KEY进行重建
2. 统计缓存设计 //要结构化
   1. 缓存为String.key=objectId+类型,value,actiontype+number拼装
   2. 布隆过滤器key为objectId+类型,key=objectId%10000来做sharding,item=objectId:objectType
   3. 在每隔一年需要开启布隆过滤器重建,重建过程需要扫描数据库按照每个KEY进行重建

### 4.4.部署架构

> 以应用视角为主线,主要描述多地部署时,应用如何运行")

 ![](https://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/nxnnxn/community-doc/main/puml/interact/relation/deploy.puml&fmt=svg&cache=no)

## 5.横向概念

### 5.1.接口定义

> 需要引入其他文档,直接使用.proto文件,通过proto文件可快速生成对接文档

### 5.2.消息定义

> 该系统的相关消息定义

### 5.3.可运维定义

#### 5.3.1.动态配置

> MSE相关应用配置链接

#### 5.3.2.降级配置

> 降级系统配置链接

#### 5.3.3.预案配置

>预案配置链接

#### 5.3.4.机器人播报配置

> 机器人配置链接

### 5.4.数据及埋点

#### 5.4.1.技术埋点

> 缓存命中率埋点

#### 5.4.2.业务埋点

> 业务提出需求的埋点

## 6.排期规划

> 



